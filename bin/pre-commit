#!/usr/bin/env node

// requires
var exec = require('child_process').exec;
var fs = require('fs');
var path = require('path');

// some status strings
var fail = '\x1B[31mfailed!\x1B[39m';
var ok = '\x1B[32mok\x1B[39m';
var notfound = '\x1B[31mfailed\x1B[31m (no script found)';
var notfoundDefault = '\x1B[33mn/a\x1B[39m (no script found)';

// longest name, for padding
var longest = 0;

var projectRoot = path.join(__dirname, '..', '..');

// set up environment
var pathKey;
var pathSep = process.platform === 'win32' ? ';' : ':';
var env = {};
for (var key in process.env) {
    if (key.toLowerCase() === 'path') {
        pathKey = key;
    }

    env[key] = process.env[key];
}
env[pathKey] = path.join(projectRoot, 'node_modules', '.bin') + pathSep + env[pathKey];

var findPackageFiles = function(dir, depth) {
    if (depth < 0) {
        return [];
    }

    var results = [];

    var list = fs.readdirSync(dir);

    list.forEach(function(file) {
        var fullPath = path.join(dir, file);
        var stat = fs.statSync(fullPath);
        if (stat && stat.isDirectory() && ['node_modules', '.git'].indexOf(file) === -1) {
            results = results.concat(findPackageFiles(path.join(dir, file), depth-1));
        }

        if (stat && stat.isFile() && file === 'package.json') {
            results.push(fullPath);
        }
    });

    return results;
};

// this method shamelessly adapted from https://github.com/cowboy/node-exit
var exit = function (code, callback) {
    var streams = [process.stdout, process.stderr];
    var drainCount = 0;

    function tryToExit() {
        if (drainCount === streams.length) {
            callback(code);
        }
    }

    streams.forEach(function (stream) {
        if (stream.bufferSize === 0) {
            drainCount++;
        } else {
            stream.write('', 'utf-8', function () {
                drainCount++;
                tryToExit();
            });

            stream.write = function () {};
        }
    });

    tryToExit();
};

// run the command for the given property
var runCmd = function (name, commandString, packageFile) {
    var pad = '';
    for (var i = 0, il = longest - (name.length + packageFile.length); i < il; ++i) {
        pad += ' ';
    }
    var logStart = packageFile + ': ' + name + ': ' + pad;

    if (!commandString) {
        console.log(logStart + notfound);
        exit(1, process.exit);
    }

    var cmd = (process.platform === 'win32' ? 'cmd /c ' : 'sh -c ') + JSON.stringify(commandString);
    exec(cmd, { cwd: path.dirname(packageFile), env: env }, function (err, stdout, stderr) {
        if (err) {
            console.log(logStart + fail);
            console.log(stdout);
            console.log(stderr);
            exit(err.code, process.exit);
        } else {
            console.log(logStart + ok);
        }
    });
};

var packages = findPackageFiles(projectRoot, 3);

var tasks = [];

packages.forEach(function (packageFile) {
    var package = require(packageFile);
    var scripts = package.scripts;
    var config = package.precommit;

    if (!config || !config.length) {
        config = ['lint'];
        scripts = scripts || {};
        scripts.lint = scripts.lint || 'jshint .';
        ['validate', 'test'].forEach(function (elem) {
            if (scripts[elem]) {
                config.push(elem);
            } else {
                console.log(packageFile + ': ' + elem + ': ' + notfoundDefault);
            }
        });
    }

    config.forEach(function (cmd) {
        var length = packageFile.length + cmd.length;
        longest = (longest < length) ? length : longest;
        var task = runCmd.bind(null, cmd, scripts[cmd], packageFile);
        tasks.push(function () {
            task.call(null, tasks.length+1);
        });
    });
});

tasks.forEach(function (task) {
    task();
});
